---
title: ' Wrangling Census data with tidyverse tools'
author: David Kane
tutorial:
  id: 03-wrangling-census-data
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: Tutorial for Chapter 3
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidycensus)
library(tidyverse)


knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

# We want the tutorial to run even if students do not have an internet
# connection, so we need to save all the downloaded data. Save the creation code
# to make replication/improvements easier.

# The tidyverse

# median_age <- get_acs(
#   geography = "county",
#   variables = "B01002_001",
#   year = 2020
# )
# write_rds(median_age, "data/median_age.rds")

median_age <- read_rds("data/median_age.rds")

race_vars <- c(
  White = "B03002_003",
  Black = "B03002_004",
  Native = "B03002_005",
  Asian = "B03002_006",
  HIPI = "B03002_007",
  Hispanic = "B03002_012"
)

# az_race <- get_acs(
#   geography = "county",
#   state = "AZ",
#   variables = race_vars,
#   summary_var = "B03002_001",
#   year = 2020
# ) 
# write_rds(az_race, "data/az_race.rds")

az_race <- read_rds("data/az_race.rds")

az_race_percent <- az_race %>%
  mutate(percent = 100 * (estimate / summary_est)) %>%
  select(NAME, variable, percent)

# Groupwise

# mn_hh_income <- get_acs(
#   geography = "county",
#   table = "B19001",
#   state = "MN",
#   year = 2016
# )
# write_rds(mn_hh_income, "data/mn_hh_income.rds")

mn_hh_income <- read_rds("data/mn_hh_income.rds")

mn_hh_income_recode <- mn_hh_income %>%
  filter(variable != "B19001_001") %>%
  mutate(incgroup = case_when(
    variable < "B19001_008" ~ "below35k", 
    variable < "B19001_013" ~ "bw35kand75k", 
    TRUE ~ "above75k"
  )) 

# Comparing ACS estimates over time


# oglala_lakota_age <- get_acs(
#   geography = "county",
#   state = "SD",
#   county = "Oglala Lakota",
#   table = "B01001",
#   year = 2020)
# write_rds(oglala_lakota_age, "data/oglala_lakota_age.rds")

oglala_lakota_age <- read_rds("data/oglala_lakota_age.rds")

college_vars <- c("B15002_015",
                  "B15002_016",
                  "B15002_017",
                  "B15002_018",
                  "B15002_032",
                  "B15002_033",
                  "B15002_034",
                  "B15002_035")

years <- 2010:2019
names(years) <- years

# college_by_year <- map_dfr(years, ~{
#   get_acs(
#     geography = "county",
#     variables = college_vars,
#     state = "CO",
#     summary_var = "B15002_001",
#     survey = "acs1",
#     year = .x
#   )
# }, .id = "year")
# write_rds(college_by_year, "data/college_by_year.rds")  

college_by_year <- read_rds("data/college_by_year.rds")
  
percent_college_by_year <- college_by_year %>%
  group_by(NAME, year) %>%
  summarize(numerator = sum(estimate),
            denominator = first(summary_est)) %>%
  mutate(pct_college = 100 * (numerator / denominator)) %>%
  pivot_wider(id_cols = NAME,
              names_from = year,
              values_from = pct_college)
  


```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- DK: Summary like Introduction. See https://ppbds.github.io/tutorial.helpers/articles/instructions.html for discussion. -->

## Introduction
### 

This tutorial covers [Chapter 3: Wrangling Census data with tidyverse tools](https://walker-data.com/census-r/wrangling-census-data-with-tidyverse-tools.html) from [*Analyzing US Census Data: Methods, Maps, and Models in R*](https://walker-data.com/census-r/index.html) by Kyle Walker. 

<!-- You will learn key functions such as [`get_acs()`](https://www.rdocumentation.org/packages/tidycensus/versions/1.5/topics/get_acs) and [`group_by()`](https://dplyr.tidyverse.org/reference/group_by.html). You will learn how to compare data over time, group and examine Census data as well as handle margin of error.    -->



## The tidyverse
### 

<!-- Covers sections 3.1 and 3.2. -->

The [tidyverse](https://tidyverse.tidyverse.org/) is a collection of R packages that are designed to work together in common data wrangling, analysis, and visualization projects. Many of these R packages, maintained by RStudio, are among the most popular R packages worldwide.

### Exercise 1

Start your code by loading in the **tidyverse** and **tidycensus** package

```{r the-tidyverse-1, exercise = TRUE}

```

```{r the-tidyverse-1-hint-1, eval = FALSE}
library(...)
library(...)
```

```{r the-tidyverse-1-test, include = FALSE}
library(tidyverse)
library(tidycensus)
```

The tidyverse is a collection of R packages that are designed to work together in common data wrangling, analysis, and visualization projects. The **tidyverse** specifically a package itself, but rather loads several core packages within the tidyverse.


### Exercise 2

For a first example, let’s request data on median age from the 2016-2020 ACS with `get_acs()` for all counties in the United States. Set `median_age` to `get_acs()` with `geography` = `"county"`, `variables` = `"B01002_001"`, and the `year` = `2020`.



```{r the-tidyverse-2, exercise = TRUE}

```

```{r the-tidyverse-2-hint-1, eval = FALSE}
median_age <- get_acs(
  geography = "...",
  variables = "B01002_001",
  year = ...
)
```

```{r the-tidyverse-2-test, include = FALSE}
median_age <- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2020
)
```

The default method for printing data used by the **tibble** package shows the first 10 rows of the dataset, which in this case prints counties in Alabama. On the right hand side of the tibble you can see both moe and estimate, both of which we will talk about later in the chapter. 



### Exercise 3

`arrange()` sorts a dataset by values in one or more columns and returns the sorted result. To view the dataset in ascending order of a given column, supply the data object(`median_age`) and a column name(let's do `estimate`) to the `arrange()` function.

```{r the-tidyverse-3, exercise = TRUE}

```

```{r the-tidyverse-3-hint-1, eval = FALSE}
arrange(..., estimate)
```

```{r the-tidyverse-3-test, include = FALSE}
arrange(median_age, estimate)
```

Per the 2016-2020 ACS, the youngest county is De Baca County, New Mexico. Two of the five youngest “counties” in the United States are independent cities in Virginia, which are treated as county-equivalents. 


### Exercise 4

New lets try to find the oldest counties in the US by median age. Use the `arrange()` function for the same dataset but instead use `desc(estimate)`.

```{r the-tidyverse-4, exercise = TRUE}

```

```{r the-tidyverse-4-hint-1, eval = FALSE}
arrange(median_age, desc(...))
```

```{r the-tidyverse-4-test, include = FALSE}
arrange(median_age, desc(estimate))
```

Notice how Sumter county is the oldest county in our tibble. The **dplyr** package in the tidyverse has a variety of functions including `arrange()`.



### 

Now try to answer the question: How many counties in the US have a median age of 50 or older?

### Exercise 5

Lets try filtering our `median_age` data set. Use `arrange()`, with `median_age` and our `estimate >= 50`. 


```{r the-tidyverse-5, exercise = TRUE}

```

```{r the-tidyverse-5-hint-1, eval = FALSE}
filter(median_age, ... >= 50)
```

```{r the-tidyverse-5-test, include = FALSE}
filter(median_age, estimate >= 50)
```

The `filter()` function queries a data set for rows where a given condition evaluates to TRUE, and retains those rows only. In this case, the data set is filtering our median_age data set for counties that have a median age of 50 or older. 

### 

What if we want to separate the columns into county and state?

### Exercise 6

Notice above how our column for location is called NAME. To make it less confusing, use the `separate()` function with your dataset `median_age`, the column `NAME`, `into = c("county","state")` , and `sep = ", "`.   



```{r the-tidyverse-6, exercise = TRUE}

```

```{r the-tidyverse-6-hint-1, eval = FALSE}
separate(
  median_age,
  NAME,
  into = c(..., ...),
  sep = ", "
)
```

```{r the-tidyverse-6-test, include = FALSE}
separate(
  median_age,
  NAME,
  into = c("county", "state"),
  sep = ", "
)
```

The `seperate()` function of the **dyplr** package allows us to separate a column. If you want to learn more information about this function, click [here](https://tidyr.tidyverse.org/reference/separate.html). 
### 

Since some data have too much information to count, we can normalize this data by dividing the total population into different variables.

### Exercise 7

Lets do this by setting `race_vars` to a vector including `White` = `"B03002_003"`, `Black` = `"B03002_004"`,
`Native` = `"B03002_005"`, `Asian` = `"B03002_006"`, `HIPI` = `"B03002_007"`, and `Hispanic` = `"B03002_012"`. 
  
```{r the-tidyverse-7, exercise = TRUE}

```

```{r the-tidyverse-7-hint-1, eval = FALSE}
race_vars <- c(
  White = "B03002_003",
  Black = "...",
  Native = "B03002_005",
  Asian = "...",
  HIPI = "B03002_007",
  Hispanic = "..."
)
```

```{r the-tidyverse-7-test, include = FALSE}
race_vars <- c(
  White = "B03002_003",
  Black = "B03002_004",
  Native = "B03002_005",
  Asian = "B03002_006",
  HIPI = "B03002_007",
  Hispanic = "B03002_012"
)
```

This separates our dataset `race_vars` to different variables. 

### Exercise 8

Let's try accessing the Decennial Census database. In order to do this, we'll use the `get_decennial()` function with the `geography`, `variables`, and `year` arguments.

Let's try to find the total American population by state. First of all, we need to access the variable containing these populations, which is `P001001`.

### 

Run `get_decennial()` below setting `geography` to  `"state"`, `variables` to `"P001001"`, and `year` to `2010`.

```{r the-tidyverse-8, exercise = TRUE}

```

```{r the-tidyverse-8-hint-1, eval = FALSE}
get_decennial(... = "...", 
              variables = "..."
              ... = 2010)
```

```{r the-tidyverse-8-test, include = FALSE}
get_decennial(geography = "state", 
              variables = "P001001",
              year = 2010)
```

### 

This should return a tibble with 52 rows and 4 columns.

The `geography` argument determines the scope of the data (such as `us` for the entire country and `county` for counties), the `variables` argument defines which variables you want to use, and the `year` argument defines the year that our data comes from.

### Exercise 9

Copy and paste your code from above and change the `year` argument, and set it to `2020`. Change the `variables` argument to `"P1_001N"`, because the `"P001001"` was renamed starting in 2020.

```{r the-tidyverse-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r the-tidyverse-9-hint-1, eval = FALSE}
get_decennial(... = "...", 
              variables = "...",
              year = ...)
```

```{r the-tidyverse-9-test, include = FALSE}
get_decennial(geography = "state", 
              variables = "P1_001N",
              year = 2020)
```

### 

By changing the `year` argument, we can specify when we want our data to be from. 

### Exercise 10

Along with the arguments we have already learned, there is also the `sumfile` argument, or "summary file". 

### 

Run the `get_decennial()` function below setting `geography` to `"state"`, `variables` to `"P1_005N"`, `year` to `2020`, and `sumfile` to `"pl"`.

```{r the-tidyverse-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r the-tidyverse-10-hint-1, eval = FALSE}
get_decennial(geography = "...",
        variables      = "...",
        year = ...,
        sumfile = "..."
)
```

```{r the-tidyverse-10-test, include = FALSE}
get_decennial(geography = "state",
        variables      = "P1_005N",
        year = 2020,
        sumfile = "pl"
)
```

### 

This retrieves information on the American Indian & Alaska Native population by state from the 2020 decennial Census. The `pl` summary file is one type that is a limited subset of variables from the decennial US Census to be used for legislative redistricting. 

To learn more about the `sumfile`, we again recommend Walker's [book](https://walker-data.com/census-r/an-introduction-to-tidycensus.html#getting-started-with-tidycensus).

### Exercise 11

Just as `get_decennial()` gets information from the Decennial Census, `get_acs()` gets information from the **A**merican **C**ommunity **S**urvey. 

### 

Run the `get_acs()` function setting `geography` to  `"state"`, `variables` to `"B05006_150"` and `year` to `2021`.

```{r the-tidyverse-11, exercise = TRUE}

```

```{r the-tidyverse-11-hint-1, eval = FALSE}
get_acs(geography = "...",
        variables      = "...",
        year = ...
)
```

```{r the-tidyverse-11-test, include = FALSE}
get_acs(geography = "state",
        variables = "B05006_150",
        year = 2021
)
```

### 

The example above fetches data on the number of residents born in Mexico by state. Notice that the tibble produced has an `estimate` and a `moe` column rather than a `value` column like the Decennial Census data. 

<!-- DK: Awkward. -->

**This is important.**

### Exercise 12

Along with the arguments, we've already learned, there is also a `survey` argument. This argument defaults to 5 year periods if not specified. We can change it to a one-year period rather than a default 5-year period by adding `survey = "acs1"`.

### 

Run `get_acs` below setting `geography` to `"state"`, `variables` to `"B05006_150"`, `survey` = `"acs1"`, and `year` to `2021`.


```{r the-tidyverse-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r the-tidyverse-12-hint-1, eval = FALSE}
get_acs(... = "...", 
        variables = "...", 
        survey = "...",
        ... = 2019)
```

```{r the-tidyverse-12-test, include = FALSE}
get_acs(geography = "state", 
        variables = "B05006_150", 
        survey = "acs1",
        year = 2021)
```

### 

The above function yields data on the number of residents born in Mexico by state in the year of just 2021 instead of a 5-year period as earlier. 

### 

Notice that the GEOID column contains the [FIPS code](https://transition.fcc.gov/oet/info/maps/census/fips/fips.txt#:~:text=FIPS%20codes%20are%20numbers%20which,to%20which%20the%20county%20belongs.) of the area the data covers. This code is a standardized way to identify different geographical areas. It gets larger as the area under consideration narrows. The FIPS for Massachusetts is 25. For Middlesex County within Massachusetts, the FIPS is 25017.


### Exercise 13

Rather than using the `variables` argument, you can supply a table name to the `table` parameter in `get_acs()`; this will return data for every variable in that table. 

Run `get_acs()` below setting `geography` to `"state"`, `table` to `"B01001"`, and `year` to `2021`

```{r the-tidyverse-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r the-tidyverse-13-hint-1, eval = FALSE}
get_acs(... = "...", 
        table = "...",
        ... = ...)
```

```{r the-tidyverse-13-test, include = FALSE}
get_acs(geography = "state", 
        table = "B01001",
        year = 2021)
```

### 

This code got all variables associated with table `B01001`, which covers sex broken down by age, from the 2017-2021 5-year ACS.

## Comparing ACS estimates over time
### 

A common task when working with Census data is to examine demographic change over time. Data from the Census API - and consequently tidycensus - only go back to the 2000 Decennial Census.

### Exercise 1

Before engaging in any sort of time series analysis of Census data, analysts need to account for potential problems that can emerge when using Census data longitudinally. One major issue that can emerge is geography changes over time.
 

Use `get_acts()` to create the dataset `oglala_lakota_age`. Within `get_acts()`, set `geography` = `"county"`, `state` = `"SD"`, `county` = `"Oglala Lakota"`, `table` =  `"B01001"` and `year` = `2020`. 

```{r comparing-acs-estimates-over-t-1, exercise = TRUE}

```

```{r comparing-acs-estimates-over-t-1-hint-1, eval = FALSE}
oglala_lakota_age <- ...(
  geography = "...",
  state = "...",
  ... = "Oglala Lakota",
  table = "...",
  year = ...
)
```

### 

The `get_acs()` function allows us obtain data from the American Community Survey. More information on this function can be found [here](https://www.rdocumentation.org/packages/tidycensus/versions/1.5/topics/get_acs).  



### Exercise 2

Print out the `oglala_lakota_age` tibble which you just created.

```{r comparing-acs-estimates-over-t-2, exercise = TRUE}

```

```{r comparing-acs-estimates-over-t-2-hint-1, eval = FALSE}
oglala_lakota_age
```

```{r comparing-acs-estimates-over-t-2-test, include = FALSE}
oglala_lakota_age
```

### 

This is a 2016-2020 age table for Oglala Lakota County, SD. This graph allows us to see the age composition of the Oglola Lakota County through this time period


### Exercise 3

Using the same code as in the first exercise in this section, change the `year` = `2010`. You should get an error. 

```{r comparing-acs-estimates-over-t-3, exercise = TRUE}

```

```{r comparing-acs-estimates-over-t-3-hint-1, eval = FALSE}
oglala_lakota_age <- get_acs(
  geography = "county",
  state = "SD",
  county = "Oglala Lakota",
  table = "B01001",
  year = ...
)
```

### 

We get an error because ten years ago, this county was named "Shannon". 

### Exercise 4

Using the same code as above, change the `county` name to `"Shannon"`. 

```{r comparing-acs-estimates-over-t-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-4-hint-1, eval = FALSE}
oglala_lakota_age <- get_acs(
  geography = "county",
  state = "SD",
  county = "...",
  table = "B01001",
  year = 2010
)
```

```{r comparing-acs-estimates-over-t-4-test, include = FALSE}
oglala_lakota_age <- get_acs(
  geography = "county",
  state = "SD",
  county = "Shannon",
  table = "B01001",
  year = 2010
)
```

### 

When looking at the two datasets, you may notice that the `GEOID` column changed from `46113` in 2010 to `46102`to 2020. This is because when a geographic entity changes their name, the Census Bureau assigns it a new `GEOID`, meaning that analysts need to take care when dealing with those changes. 


### Exercise 5

 Let’s say that we are interested in analyzing the percentage of residents age 25 and up with a 4-year college degree for counties in Colorado from the 2019 1-year ACS. 
 
 Set the dataset `co_college` to the function `get_acs()`. Inside the function, set `geography` = `"county"`, `variables` = `"DP02_0068P"`, `state` = `"CO"`, `survey` = `"acs1"` and `year` = `2019`.  
 

```{r comparing-acs-estimates-over-t-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-5-hint-1, eval = FALSE}
... <- get_acs(
  ... = "county",
  variables = "...",
  ... = "CO",
  survey = "...",
  year = ...
)
```

```{r comparing-acs-estimates-over-t-5-test, include = FALSE}
co_college19 <- get_acs(
  geography = "county",
  variables = "DP02_0068P",
  state = "CO",
  survey = "acs1",
  year = 2019
)
```

### 

Notice how Boulder County, home to the University of Colorado, has a very high percentage of its population with a 4-year degree or higher.

### Exercise 6

Copying the code above, lets change the `year` to `2018`. 

```{r comparing-acs-estimates-over-t-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-6-hint-1, eval = FALSE}
co_college19 <- get_acs(
  geography = "county",
  variables = "DP02_0068P",
  state = "CO",
  survey = "acs1",
  year = ...
)
```

```{r comparing-acs-estimates-over-t-6-test, include = FALSE}
co_college19 <- get_acs(
  geography = "county",
  variables = "DP02_0068P",
  state = "CO",
  survey = "acs1",
  year = 2018
)
```

### 

Why are the values completely changed and different? This is because variable ID's change every year and as a result should not be used for time-series analysis. These variable ID's actually represent the civilian population age 18 and up, and have nothing to do with educational attainment.

### Exercise 7

If our data is compromised from geography changes and variable ID changes, what is the best way to make a time-series analysis? The safest way to compare data is through Comparison Profile Tables!

Let's get data from the ACS Comparison Profile on inflation-adjusted median household income for counties and county-equivalents in Alaska.

Set the dataset `ak_income_compare` to the function `get_acs()`. Inside the function, set `geography` = `"county"`, `variables` to a vector of `income15 = "CP03_2015_062"` and `income20 = "CP03_2020_062"`, `state` = `"AK"`, and `year` = `2020`.

```{r comparing-acs-estimates-over-t-7, exercise = TRUE}

```

```{r comparing-acs-estimates-over-t-7-hint-1, eval = FALSE}
... <- get_acs(
  ... = "county",
  variables = c(
    income15 = "...",
    income20 = "..."
  ),
  ... = "AK",
  year = ...
)
```

```{r comparing-acs-estimates-over-t-7-test, include = FALSE}
ak_income_compare <- get_acs(
  geography = "county",
  variables = c(
    income15 = "CP03_2015_062",
    income20 = "CP03_2020_062"
  ),
  state = "AK",
  year = 2020
)
```

### 

These tables are available for both the 1-year and 5-year ACS, and allow for comparison of demographic indicators over the past five years for a given year. For the 2016-2020 ACS, the “comparison year” is 2015, representing the closest non-overlapping 5-year dataset, which in this case is 2011-2015.

### Exercise 8

Let’s re-engineer the analysis above on educational attainment in Colorado counties, which below will be computed for a time series from 2010 to 2019. We only need a few variables (representing estimates of populations age 25+ who have finished a 4-year degree or graduate degrees, by sex), we’ll request those variables directly rather than the entire B15002 table. 

Set `college_wars` equal to a vector of `"B15002_015"`, `"B15002_016"`, `"B15002_017"`, `"B15002_018"`, `"B15002_032"`, `"B15002_033"`, `"B15002_034"`, and `"B15002_035"`. 



```{r comparing-acs-estimates-over-t-8, exercise = TRUE}

```

```{r comparing-acs-estimates-over-t-8-hint-1, eval = FALSE}
college_vars <- c("...",
                  "B15002_016",
                  "B15002_017",
                  "...",
                  "...",
                  "B15002_033",
                  "...",
                  "B15002_035")
```

```{r comparing-acs-estimates-over-t-8-test, include = FALSE}
college_vars <- c("B15002_015",
                  "B15002_016",
                  "B15002_017",
                  "B15002_018",
                  "B15002_032",
                  "B15002_033",
                  "B15002_034",
                  "B15002_035")
```

### 

If we want data on college career holders from 2010 to 2019, we will have a lot of `get_acs()` functions. To reduce the unnecessary work, we will use iterations to avoid repetitive coding. This is similar to the loop operators `for` an `while` 


### Exercise 9

The **purr** package has a variety of iteration functions such as `map_*()`. The function `map_dfr()` is especially useful in tidycensus, as it iterates over an input and applies it to a function or process defined by the user, then row-binds the result into a single data frame. 

Set `years` to `2010:2019`. On a separate line type the function `names()` with the argument as `years`. Set this function to `years`. 



```{r comparing-acs-estimates-over-t-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-9-hint-1, eval = FALSE}
years <- ....
names(..) <- years
```

```{r comparing-acs-estimates-over-t-9-test, include = FALSE}
years <- 2010:2019
names(years) <- years
```

### 

The `names()` function allows us to get or set the names of an object. More information on this function can be found [here](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/names)

### Exercise 10

Copy the code above. Then set `college_by_year` to the function `map_dfr()` with the first argument as `years`. Inside the `map_dfr()` function, set the second argument to `~{ getacs() }`. It is fine to have an error.  

```{r comparing-acs-estimates-over-t-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-10-hint-1, eval = FALSE}

years <- 2010:2019
names(years) <- years

college_by_year <- ...(..., ~{
  get_acs() })
```

```{r comparing-acs-estimates-over-t-10-test, include = FALSE, eval = FALSE}
years <- 2010:2019
names(years) <- years

college_by_year <- map_dfr(years, ~{
  get_acs() })
```

### 

The tilde (`~`) operator and the curly brackets (`{}`) means that the code will run once for each element of `years`. 

### Exercise 11

Copy the code above. Within the `get_acs()` function, set `geography` = `"county"`, `variables` = `collge_vars`, `state` = `"CO"`, `summary_var` = `"B15002_001"`, `survey` = `"acs1"` and `year` = `.x`. Within the `map_dfr()` function, set the third argument `.id` equal to `"year"`

```{r comparing-acs-estimates-over-t-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-11-hint-1, eval = FALSE}
years <- 2010:2019
names(years) <- years

college_by_year <- map_dfr(years, ~{
  get_acs(
    geography = "county",
    variables = ...,
    ... = "CO",
    summary_var = "...",
    ... = "acs1",
    year = .x
  )
}, .id = "...")
```

```{r comparing-acs-estimates-over-t-11-test, include = FALSE}
years <- 2010:2019
names(years) <- years

college_by_year <- map_dfr(years, ~{
  get_acs(
    geography = "county",
    variables = college_vars,
    state = "CO",
    summary_var = "B15002_001",
    survey = "acs1",
    year = .x
  )
}, .id = "year")
```

### 

Let's go over the code so that you can understand. A numeric vector of `years` is defined with the syntax 2010:2019. This will create a vector of `years` at 1-year intervals. 

Then the function map_dfr() takes three arguments. The first argument, `years` is the object that the function will iterate over. The second argument uses the formula to create data for each element of `years` and then outputs the data into a single data frame. The third argument makes a new column that will output the data for `year`. 

### Exercise 12

Lets look at the results! 

Pipe `college_by_year` using `%>%` to the function `arrange()`. Within `arrange()`, set the first argument as `NAME`, the second as `variable` and the third as `year`. 

```{r comparing-acs-estimates-over-t-12, exercise = TRUE}

```

```{r comparing-acs-estimates-over-t-12-hint-1, eval = FALSE}
... %>% 
  arrange(NAME, ..., ...)
```

```{r comparing-acs-estimates-over-t-12-test, include = FALSE}
college_by_year %>% 
  arrange(NAME, variable, year)
```

### 

The result is a long-form data set that contains a time series of each requested ACS variable for each county in Colorado that is available in the 1-year ACS. 

### Exercise 13

Let's calculate the percentage of the population age 25 and up with a 4-year college degree using our data from before.  

Set `percent_college_by_year` to `college_by_year`. Then pipe `college_by_year` using `%>%` to the `group_by()` function with the first argument as `NAME` and the second argument as `year`. 
```{r comparing-acs-estimates-over-t-13, exercise = TRUE}

```

```{r comparing-acs-over-t-12-hint, eval = FALSE }
percent_college_by_year <- ... %>%
  group_by(..., year)
```

```{r comparing-acs-estimates-over-t-13-test, include = FALSE}
percent_college_by_year
```

### 

### Exercise 14

Copy the code above. Continue using the pipe `%>%` to the function `summarize()`. For the first argument of `summarize()`, set `numerator` equal to `sum(estimate)`. For the second argument of `summarize()`, set `denominator` to `first(summary_est)`. 

```{r comparing-acs-estimates-over-t-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-14-hint-1, eval = FALSE}
... <- college_by_year %>%
  group_by(..., year) %>%
  summarize(... = sum(estimate),
            ... = first(...))
```

```{r comparing-acs-estimates-over-t-14-test, include = FALSE}
percent_college_by_year
```

### 

The function `summarize()` creates a new data frame. More information can be found [here](https://dplyr.tidyverse.org/reference/summarise.html)

### Exercise 15

Copy the code above. Continue the pipe `%>%` to the function `mutate()`. Within the function, set `pct_college` = `100` times `(numerator/denominator)`. 

```{r comparing-acs-estimates-over-t-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-15-hint-1, eval = FALSE}
percent_college_by_year <- college_by_year %>%
  group_by(NAME, year) %>%
  summarize(numerator = sum(estimate),
            denominator = first(summary_est)) %>%
  mutate(... = ... * (numerator / ...)) 

```

```{r comparing-acs-estimates-over-t-15-test, include = FALSE}
percent_college_by_year
```

### 

The `mutate()` function allows us the create, modify and delete columns. More information about this function can be found [here](https://dplyr.tidyverse.org/reference/mutate.html)

### Exercise 16

Copy the code above. Continue the pipe `%>%` to the function `pivot_wider()`. Within the function, set `id_cols` = `NAME`, `names_from` = `year`, and `values_from` = `pct_college`. 

```{r comparing-acs-estimates-over-t-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r comparing-acs-estimates-over-t-16-hint-1, eval = FALSE}
percent_college_by_year <- college_by_year %>%
  group_by(NAME, year) %>%
  summarize(numerator = sum(estimate),
            denominator = first(summary_est)) %>%
  mutate(pct_college = 100 * (numerator / denominator)) %>%
  ...(... = NAME,
              names_from = ...,
              ... = pct_college)
```

```{r comparing-acs-estimates-over-t-16-test, include = FALSE}
percent_college_by_year
```

### 

The code below outlines a `group_by() %>% summarize()` workflow for calculating the percentage of the population age 25 and up with a 4-year college degree, then uses the `pivot_wider()` function from the tidyr package to spread the years across the columns for tabular data display. If you want to know more information about the `pivot_wider()` function click [here](https://tidyr.tidyverse.org/reference/pivot_wider.html)

## Handling margins of error with tidycensus
### 

The American Community Survey is based on a sample with estimates characterized by margins of error, and by default MOE is set to a 90 confidence interval. This can be translated roughly as “we are 90 percent sure that the true value falls within a range defined by the estimate plus or minus the margin of error.” 

### Exercise 1

Lets look at data on median household income by county in Rhode Island using the default `moe_level` of 90. 

Type the function `get_acs()`. Within this function, set `geography` = `"county"`, `state` = `"Rhode Island"`, `variables` = `"B19013_001"`, and `year` = `2020`. 

```{r handling-margins-of-error-with-1, exercise = TRUE}

```

```{r handling-margins-of-error-with-1-hint-1, eval = FALSE}
get_acs(
  geography = ...,
  ... = "Rhode Island",
  ... = ...,
  year = ...
)
```

```{r handling-margins-of-error-with-1-test, include = FALSE}
get_acs(
  geography = "county",
  state = "Rhode Island",
  variables = "B19013_001",
  year = 2020
)
```

### 

The data can be translated to saying, "We are 90% confident that the median household income in the county of Rhode Island falls within the range of the `estimate` plus or minus the `moe`." For example, our estimate of the average household income in Bristol County, Rhode Island is $85,413 with a 90% confidence interval of +/- $6,122.

### Exercise 2

Rather than using the default 90% margin of error, lets change the argument using the `get_acs()` function. Side note, the `moe_level` argument can only be either 90, 95 or 99.

Copy the code above and add an argument `moe_level` = `99`. 

```{r handling-margins-of-error-with-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r handling-margins-of-error-with-2-hint-1, eval = FALSE}
get_acs(
  geography = "county",
  state = "Rhode Island",
  variables = "B19013_001",
  year = 2020,
  moe_level = ...
)
```

```{r handling-margins-of-error-with-2-test, include = FALSE}
get_acs(
  geography = "county",
  state = "Rhode Island",
  variables = "B19013_001",
  year = 2020,
  moe_level = 99
)
```

### 

Look at the data and notice how the values for the `moe` column has changed. The stricter margin of error increases the size of the confidence interval. In simpler terms, if you want to be more confident (i.e., set a higher `moe_level`) in the estimate, then your margin of error will increase. 

### Exercise 3

For small geographies or small populations, margins of error can get quite large, in some cases exceeding their corresponding estimates. Let's examine data on age groups by sex for the population age 65 and older for Census tracts in Salt Lake County, Utah.

Set `vars` to the function `paste0()`. Within the function, set the first argument as `"B01001_0"` and the second arguement as a vector of `20:25` and `44:49`. On the next line print out `vars`. 

```{r handling-margins-of-error-with-3, exercise = TRUE}

```

```{r handling-margins-of-error-with-3-hint-1, eval = FALSE}
... <- paste0(..., c(20:25, ...))

vars
```

```{r handling-margins-of-error-with-3-test, include = FALSE}
vars <- paste0("B01001_0", c(20:25, 44:49))

vars
```

### 

Let's look at this code. First we are evaluating the `20:25` and `44:49` expressions to generate a vector of numbers for suffixes of variable IDs. Next we are using the `c()` function to combine the two vectors into a single vector. Lastly the `paste0()` function concatenates the prefix `"B01001_0"` with the variable IDs we just created. 

### Exercise 4

The resulting object `vars` allows us to request variables in a call to `get_acs()`. 

Set `salt_lake` to the function `get_acs()`. Within the function, set `geography` = `"tract"`, `variables` = `vars`, state = `"Utah"`, `county` = `"Salt Lake"`, and `year` = `2020`. 

```{r handling-margins-of-error-with-4, exercise = TRUE}

```

```{r handling-margins-of-error-with-4-hint-1, eval = FALSE}
... <- get_acs(
  ... = "tract",
  ... = vars,
  state = ...,
  county = ...,
  ... = 2020
)
```

```{r handling-margins-of-error-with-4-test, include = FALSE}
salt_lake <- get_acs(
  geography = "tract",
  variables = vars,
  state = "Utah",
  county = "Salt Lake",
  year = 2020
)
```

### 

The `paste0()` function we used for the `vars` object allows us to concatenate vectors after converting to character. More information about the function and its arguments can be found [here](https://stat.ethz.ch/R-manual/R-devel/library/base/html/paste.html)

### Exercise 5

Now we should examine our data using the `filter()` function. 

Set `example_tract` to the `salt_lake` object we used above. Now pipe the `salt_lake` object using `%>%` to the function `filter()`. Within `filter()`, set `GEOID` equals to `"49035100100"`. On a separate line, pipe `example_tract` to the `select()` function. Within the function, type `-NAME`.  

```{r handling-margins-of-error-with-5, exercise = TRUE}

```

```{r handling-margins-of-error-with-5-hint-1, eval = FALSE}
example_tract <- ... %>%
  filter(GEOID == ...)

example_tract %>% 
  select(...)
```

```{r handling-margins-of-error-with-5-test, include = FALSE}
example_tract <- salt_lake %>%
  filter(GEOID == "49035100100")

example_tract %>% 
  select(-NAME)
```

### 

In many cases, the ma
rgins of error exceed their corresponding estimates. For example, for the variable `B01001_0025` it suggests that or the male population age 85 and up, there are anywhere between 0 and 45 people in that Census tract. This can make ACS data for small geographies problematic for planning and analysis purposes.


### Exercise 6

A potential solution to large margins of error for small estimates in the ACS is to aggregate data upwards until a satisfactory margin of error to estimate ratio is reached.

The `moe_prop()` function calculates a margin of error for a derived proportion. Type the function, then set the arguements to `25`, `100`, `5`, and `3`. 

```{r handling-margins-of-error-with-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r handling-margins-of-error-with-6-hint-1, eval = FALSE}
moe_prop(25, ..., 5, ...)
```

```{r handling-margins-of-error-with-6-test, include = FALSE}
moe_prop(25, 100, 5, 3)
```

### 

we had an ACS estimate of 25 with a margin of error of 5 around that estimate. This allowed us the determine the margin of error around the derived proportion of 0.25. The US Census Bureau publishes formulas to calculate margin of errors with the functions [`moe_prop()`](https://rdocumentation.org/packages/tidycensus/versions/1.4.4/topics/moe_prop), [`moe_sum()`](https://www.rdocumentation.org/packages/tidycensus/versions/1.5/topics/moe_sum), and [`moe_product()`](https://www.rdocumentation.org/packages/tidycensus/versions/1.5/topics/moe_product). Click on the functions to learn more about them.   

### Exercise 7

```{r handling-margins-of-error-with-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r handling-margins-of-error-with-7-hint-1, eval = FALSE}

```

```{r handling-margins-of-error-with-7-test, include = FALSE}

```

### 

## Summary
### 

<!-- Two to four sentences which bring the lessons of the tutorial together for the student. What do they know now that they did not know before? How does this tutorial connect to other tutorials? OK if this is very similar to the Introduction. You made a promise as to what they would learn. You (we hope!) kept that promise.-->

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
